Implicit Returns - Methods in Ruby will automatically return the evaluation of their last executed expression. You will still need to use the explicit return keyword to do an early return.

Omitting parentheses for method calls with no arguments - When calling a method without passing any arguments, we'll often drop the parentheses altogether.

Use single line conditionals when possible - When we have a single line in the body of a simple if statement (that is not attached to an elsif or else), we can turn it into a one-liner: puts "dont forget an umbrella" if raining

Use built-in methods -

p num % 2 == 0
# Preferred by a Rubyist
p num.even?

p people[people.length - 1]

# Preferred by a Rubyist
p people[-1]
p people.last

def repeat_hi(num)
    num.times { puts "hi" }
end


def all_numbers_even?(nums)
    nums.all? { |num| num.even? }
end

all?
Return true when all elements result in true when passed into the block.

p [2, 4, 6].all? { |el| el.even? }  # => true
p [2, 3, 6].all? { |el| el.even? }  # => false

any?
Return true when all at least one element results in true when passed into the block.

p [3, 4, 7].any? { |el| el.even? }  # => true
p [3, 5, 7].any? { |el| el.even? }  # => false

none?
Return true when no elements result in true when passed into the block.

p [1, 3, 5].none? { |el| el.even? } # => true
p [1, 4, 5].none? { |el| el.even? } # => false

one?
Return true when exactly one element results in true when passed into the block.

p [1, 4, 5].one? { |el| el.even? }  # => true
p [1, 4, 6].one? { |el| el.even? }  # => false
p [1, 3, 5].one? { |el| el.even? }  # => false

count
Return a number representing the count of elements that result in true when passed into the block.

p [1, 2, 3, 4, 5, 6].count { |el| el.even? }    # => 3
p [1, 3, 5].count { |el| el.even? }             # => 0

sum
Return the total sum of all elements

p [1, -3, 5].sum   # => 3

max and min
Return the maximum or minimum element

p [1, -3, 5].min    # => -3
p [1, -3, 5].max    # => 5
p [].max            # => nil

flatten
Return the 1 dimensional version of any multidimensional array

multi_d = [
    [["a", "b"], "c"],
    [["d"], ["e"]],
    "f"
]

p multi_d.flatten   # => ["a", "b", "c", "d", "e", "f"]

Here are the core RSpec terms you'll see in every spec file:

describe names the method being tested
it expresses the expected behavior of the method being tested
expect shows how that behavior is tested

--PRY--
You can begin a pry session simply by using the command pry in your command line.
You can use ls to list methods that you can use in a given context. For example, you can see what methods you have available to use on strings by entering ls String.
You can use ri, which is built into Ruby, to show the documentation for a given method. For example, if you want to learn more about the end_with? method from the example above, you can run ri String#end_with?. (Be sure to use Class#method for instance methods and Class::method for class methods.)
load is another method built into Ruby that you'll use often in Pry. It allows you to load an entire .rb file into Pry and begin playing with it.

--OOP--

Abstraction
In OOP, abstraction is the process of exposing essential features of an object while hiding inner details that are not necessary to using the feature. Take this analogy: Many drivers do not understand the mechanical details of how a steering wheel works, but they can still use the steering wheel to drive a car. In a similar way, our classes should have methods that are simple to use because they hide complex logic inside of them. Let's explore some examples.

Encapsulation
Similar to abstraction, encapsulation closely relates methods and data attributes together with the hope of preventing misuse. For us, the goal of encapsulation is to give users access to the things that are safe for them to use. Some data we may choose to keep private or purposefully hide from outside users for the sake of security. One common way to encapsulate data attributes is by making them only accessible through methods that we explicitly design as programmers!

--RECURSION--

In programming, Recursion is when a method calls itself. As we have seen during the course, using helper methods can be very useful when it comes to solving problems. In our classic helper method examples, we have commonly called methods from other methods. Recursion is a similar process except we are calling the same method.

In recursive methods, we need to implement a way to stop the recursive loop and prevent it from looping forever. We took care of the infinite loop issue in our countDown by using an if statement that prevents another recursive call. In general, we call such a statement the base case

A recursive method consists of two fundamental parts:

the base case where we halt the recursion by not making a further call
the recursive step where we continue the recursion by making another subsequent call